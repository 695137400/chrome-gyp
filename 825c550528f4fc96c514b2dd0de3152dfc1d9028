{
  "comments": [
    {
      "key": {
        "uuid": "42ffbda1_cfac4596",
        "filename": "test/lib/TestGyp.py",
        "patchSetId": 2
      },
      "lineNbr": 652,
      "author": {
        "id": 1003232
      },
      "writtenOn": "2018-12-06T04:49:38Z",
      "side": 1,
      "message": "This is a Mac-only call, but I figured I\u0027d change the output to be safe anyway.",
      "revId": "825c550528f4fc96c514b2dd0de3152dfc1d9028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b31d472_4307808e",
        "filename": "test/lib/TestGyp.py",
        "patchSetId": 2
      },
      "lineNbr": 748,
      "author": {
        "id": 1003232
      },
      "writtenOn": "2018-12-06T04:49:38Z",
      "side": 1,
      "message": "During testing I tripped over a few places (usually in dumpbin) where the output wasn\u0027t actually valid UTF-8. I didn\u0027t stare at the output enough to figure out if it was just a different character encoding, or if there was something weird going on. I figured that since we\u0027re just doing substring matching on the output, ignoring the errors was probably good\nenough, and I decided to do this everywhere to be more consistent, rather than try\nto figure out what error handling might be needed in each situation. \n\nIt might be good to go back and patch the other uses of .decode() I changed in earlier patches to do the same thing.",
      "revId": "825c550528f4fc96c514b2dd0de3152dfc1d9028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dff8ab94_2de23b7e",
        "filename": "test/lib/TestGyp.py",
        "patchSetId": 2
      },
      "lineNbr": 748,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2018-12-06T15:29:22Z",
      "side": 1,
      "message": "\u003e During testing I tripped over a few places (usually in dumpbin) where the output wasn\u0027t actually valid UTF-8. I didn\u0027t stare at the output enough to figure out if it was just a different character encoding, or if there was something weird going on. I figured that since we\u0027re just doing substring matching on the output, ignoring the errors was probably good\n\u003e enough, and I decided to do this everywhere to be more consistent, rather than try\n\u003e to figure out what error handling might be needed in each situation. \n\u003e \n\u003e It might be good to go back and patch the other uses of .decode() I changed in earlier patches to do the same thing.\n\nInstead of a flaky UTF-8 decode, can we deal with everything as bytes? You can strip and split bytes too… Then, if you really need a string, you could just decode what you need, build_tool. Much less likely to run into trouble with that (although it’s certainly still possible…)",
      "parentUuid": "1b31d472_4307808e",
      "revId": "825c550528f4fc96c514b2dd0de3152dfc1d9028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2fa52714_3a40d7e9",
        "filename": "test/lib/TestGyp.py",
        "patchSetId": 2
      },
      "lineNbr": 748,
      "author": {
        "id": 1003232
      },
      "writtenOn": "2018-12-06T16:18:07Z",
      "side": 1,
      "message": "The problem is that down the road the callers end up looking for substring matches, which either need this to be turned into a string or have the callers encode the string in a byte sequence. So leaving this as a byte sequence doesn\u0027t really help anything.",
      "parentUuid": "dff8ab94_2de23b7e",
      "revId": "825c550528f4fc96c514b2dd0de3152dfc1d9028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "667b7566_3bfac7d6",
        "filename": "test/lib/TestGyp.py",
        "patchSetId": 2
      },
      "lineNbr": 748,
      "author": {
        "id": 1174099
      },
      "writtenOn": "2018-12-06T16:27:39Z",
      "side": 1,
      "message": "\u003e The problem is that down the road the callers end up looking for substring matches, which either need this to be turned into a string or have the callers encode the string in a byte sequence. So leaving this as a byte sequence doesn\u0027t really help anything.\n\nBut in cases like this, where the only downstream is build_tool and you use it right here, why not at least do the stripping and splitting in the bytes domain, and then decode the result to UTF-8 when you need it? Then you don’t have to try converting stuff that you don’t need or care about.\n\nSo instead of\n\n        build_tool \u003d subprocess.check_output(args1).decode(\n            \u0027utf-8\u0027, \u0027ignore\u0027).strip().split(\u0027\\r\\n\u0027).pop().split(\u0027 \u0027).pop()\n\nit’d be\n\n        build_tool \u003d subprocess.check_output(args1).strip().split(b\u0027\\r\\n\u0027).\\\n            pop().split(b\u0027 \u0027).pop().decode(\u0027utf-8\u0027, \u0027ignore\u0027)",
      "parentUuid": "2fa52714_3a40d7e9",
      "revId": "825c550528f4fc96c514b2dd0de3152dfc1d9028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "861de6a8_3fb3371d",
        "filename": "test/relative/gyptest-default.py",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 1003232
      },
      "writtenOn": "2018-12-06T04:49:38Z",
      "side": 1,
      "message": "Could probably just call open(sln, \u0027r\u0027, encoding\u003d\u0027utf-8\u0027).read() instead ...",
      "revId": "825c550528f4fc96c514b2dd0de3152dfc1d9028",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}